"use strict";
// Copyright (c) 2017, Shellyl_N and Authors
// license: ISC
// https://github.com/shellyln
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSaver = void 0;
const Logger_1 = require("./Logger");
const is_node_1 = require("../runtime/is-node");
const require_dynamic_1 = require("../runtime/require-dynamic");
class FileSaver {
    static saveTextAs_node(pathOrFileName, text, encoding) {
        const promise = new Promise((resolve, reject) => {
            try {
                const fs = require_dynamic_1.default("fs");
                fs.writeFile(pathOrFileName, text, encoding === "utf-8" || encoding === "UTF-8" ? "utf8" : encoding, (err) => {
                    if (err) {
                        Logger_1.Logger.log("FileSaver#saveTextAs_node:writeFile:" + err);
                        reject(err);
                    }
                    else {
                        resolve(true);
                    }
                });
            }
            catch (e) {
                Logger_1.Logger.log("FileSaver#saveTextAs_node:" + e);
                reject(e);
            }
        });
        return promise;
    }
    static saveTextAs_html5(pathOrFileName, text, encoding) {
        const promise = new Promise((resolve, reject) => {
            try {
                if (encoding === "utf-8" || encoding === "UTF-8") {
                    const blob = new Blob([text], { type: "text/plain" });
                    if (window.navigator.msSaveOrOpenBlob) {
                        window.navigator.msSaveOrOpenBlob(blob, pathOrFileName);
                        resolve(true);
                    }
                    else {
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = pathOrFileName;
                        const ua = window.navigator.userAgent.toLowerCase();
                        // const isMSIE    = ua.indexOf('trident/') !== -1;
                        // const isMSEdge  = ua.indexOf('edge/')    !== -1;
                        // const isFirefox = ua.indexOf('firefox/') !== -1 && ua.indexOf('edge/') === -1;
                        const isChrome = ua.indexOf("chrome/") !== -1 && ua.indexOf("edge/") === -1;
                        if (!isChrome)
                            document.body.appendChild(a);
                        a.click();
                        window.setTimeout(() => {
                            window.URL.revokeObjectURL(url);
                            if (!isChrome)
                                document.body.removeChild(a);
                            resolve(true);
                        }, 10);
                    }
                }
                else {
                    Logger_1.Logger.log("FileSaver#saveTextAs_html5:unsupported text encoding:" + encoding);
                    reject("unsupported text encoding");
                }
            }
            catch (e) {
                Logger_1.Logger.log("FileSaver#saveTextAs_html5:" + e);
                reject(e);
            }
        });
        return promise;
    }
    static saveBinaryAs_node(pathOrFileName, data) {
        const promise = new Promise((resolve, reject) => {
            try {
                const fs = require_dynamic_1.default("fs");
                fs.writeFile(pathOrFileName, data, (err) => {
                    if (err) {
                        Logger_1.Logger.log("FileSaver#saveBinaryAs_node:writeFile:" + err);
                        reject(err);
                    }
                    else {
                        resolve(true);
                    }
                });
            }
            catch (e) {
                Logger_1.Logger.log("FileSaver#saveBinaryAs_node:" + e);
                reject(e);
            }
        });
        return promise;
    }
    static saveBinaryAs_html5(pathOrFileName, data) {
        const promise = new Promise((resolve, reject) => {
            try {
                const blob = new Blob([data], { type: "application/octet-binary" });
                if (window.navigator.msSaveOrOpenBlob) {
                    window.navigator.msSaveOrOpenBlob(blob, pathOrFileName);
                    resolve(true);
                }
                else {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = pathOrFileName;
                    const ua = window.navigator.userAgent.toLowerCase();
                    // const isMSIE    = ua.indexOf('trident/') !== -1;
                    // const isMSEdge  = ua.indexOf('edge/')    !== -1;
                    // const isFirefox = ua.indexOf('firefox/') !== -1 && ua.indexOf('edge/') === -1;
                    const isChrome = ua.indexOf("chrome/") !== -1 && ua.indexOf("edge/") === -1;
                    if (!isChrome)
                        document.body.appendChild(a);
                    a.click();
                    window.setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        if (!isChrome)
                            document.body.removeChild(a);
                        resolve(true);
                    }, 10);
                }
            }
            catch (e) {
                Logger_1.Logger.log("FileSaver#saveBinaryAs_html5:" + e);
                reject(e);
            }
        });
        return promise;
    }
    static saveTextAs(pathOrFileName, text, encoding = "utf-8") {
        if (is_node_1.default) {
            return this.saveTextAs_node(pathOrFileName, text, encoding);
        }
        else {
            return this.saveTextAs_html5(pathOrFileName, text, encoding);
        }
    }
    static saveBinaryAs(pathOrFileName, data) {
        if (is_node_1.default) {
            return this.saveBinaryAs_node(pathOrFileName, data);
        }
        else {
            return this.saveBinaryAs_html5(pathOrFileName, data);
        }
    }
}
exports.FileSaver = FileSaver;
//# sourceMappingURL=FileSaver.js.map